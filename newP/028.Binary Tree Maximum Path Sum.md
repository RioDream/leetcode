##Binary Tree Maximum Path Sum    


分治思想的很好的运用

		class Solution {
		public:
		    int maxPathSum(TreeNode *root) {
		        if(!root) return 0;
		        
		        //别忘初始化
		        int maxSumInTree=INT_MIN;
		        int maxSumIncludeRoot=INT_MIN;
		        
		        maxPathSumHelper(root, maxSumInTree, maxSumIncludeRoot);
		        return maxSumInTree;
		    }

		private:
		    void maxPathSumHelper(TreeNode* root, int& maxSumInTree, int& maxSumStartWithRoot){
		        if(!root->left && !root->right){
		            maxSumInTree = root->val;
		            maxSumStartWithRoot = root->val;
		            return;
		        }
		        
		        //如果不初始化，使用这些变量，就会造成随机的效果
		        int maxSumInTree_left=INT_MIN;
		        int maxSumInTree_right=INT_MIN;
		        int maxSumStartWithRoot_left=INT_MIN;
		        int maxSumStartWithRoot_right=INT_MIN;
		        
		        if(root->left)  maxPathSumHelper(root->left, maxSumInTree_left, maxSumStartWithRoot_left);
		        if(root->right) maxPathSumHelper(root->right, maxSumInTree_right, maxSumStartWithRoot_right);
		        
		        //merge 三者选大的
		        maxSumStartWithRoot = root->val + max(maxSumStartWithRoot_left,maxSumStartWithRoot_right);
		        maxSumStartWithRoot = max(maxSumStartWithRoot, root->val);
		        
		        //三者中选大的
		        int localMaxSumIncludeRoot=root->val;
		        if(maxSumStartWithRoot_left>0) localMaxSumIncludeRoot += maxSumStartWithRoot_left;
		        if(maxSumStartWithRoot_right>0) localMaxSumIncludeRoot += maxSumStartWithRoot_right;
		        
		        maxSumInTree = max(maxSumInTree_left, localMaxSumIncludeRoot);
		        maxSumInTree = max(maxSumInTree_right, maxSumInTree);
		    }
		};