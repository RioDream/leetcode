##N-Queens   
N后问题， 回溯法的经典使用案例

1. 递归版， 很好写

    class Solution {
    public:
        vector<vector<string> > solveNQueens(int n) {
            vector<string> oneSolution;
            DFS(0, n, oneSolution);
            return solutions;
        }

    private:
        void DFS(int i, const int n, vector<string>& oneSolution){
            if(i==n){
                solutions.push_back(oneSolution);
                return;
            }
            for(int j=0;j<n;j++){
                if(checkValid(i, j, oneSolution)){
                    string s(n, '.'); 
                    s[j] = 'Q';
                    oneSolution.push_back(s);
                    DFS(i+1, n, oneSolution);
                    oneSolution.pop_back();
                }
            }
        }
        
        bool checkValid(int i, int j, vector<string>& oneSolution){
            if(i==0) return true;
            
            const int n = oneSolution[0].size();
            for(int ii=0;ii<=i-1;ii++){
                for(int jj=0;jj<n;jj++){
                    if(oneSolution[ii][jj]=='Q' && (jj==j || (ii-i)==(jj-j) ||(ii-i)==(j-jj) )){
                        return false;
                    }
                }
            }
            return true;
        }
        
        
        vector<vector<string>> solutions;
    };

2. 早期的一版递归版
    不同之处在于使用一个vector来记录每一行的位置， 而不是生成的地图， 更加高效了

    class Solution {
public:
    vector<vector<string> > solveNQueens(int n) {
        x = new int[n+1]();
        backTrack(1,n); //begin from 1th row 
        return output;
    }
    
private:
    vector<vector<string> > output;
    int* x;
    void backTrack(int r,int n){
        if(r>n){
            //convert x[] to vector
            vector<string> xVec;
            for(int i=1;i<n+1;i++){
                string row;
                row.assign(n,'.'); //can not use ".", cause the "." will return a char* 
                row.replace(x[i]-1,1,"Q");
                xVec.push_back(row);
                //cout<<row<<endl;
            }
            //cout<<endl;
            output.push_back(xVec);
        }else{
            for(int i=1;i<n+1;i++){ //trav all cols
                x[r] = i;
                if(place(r)){ //check if the current pos in rth row is ok
                    backTrack(r+1,n);
                }
                // you should continue
                //else{
                //   return;
                //}
            }
        }
    }
    
    bool place(int r){
        for(int i=1;i<r;i++){
            if(abs(i-r)==abs(x[i]-x[r]) || x[i]==x[r]){ 
                return false;
            }
        }
        return true;
    }
    
    
};


