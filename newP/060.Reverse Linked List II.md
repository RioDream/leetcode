##Reverse Linked List II    

Reverse 一个范围内的 node， 简直就是 Reverse Node In K Group 问题的简化版。



8-12

class Solution {
public:
    ListNode *reverseBetween(ListNode *head, int m, int n) {
        if(m==n) return head;
        
        int count = -1;
        ListNode* hair = new ListNode(-1);
        hair->next = head;
        
        head = hair;
        while(head){
            count++;
            if(count==m-1) break;
            head = head->next;
        }
        
        //断裂处的主链
        ListNode* prevNode = head;
        
        head = head->next;
        count++;
        //至此，指向第m个节点
        
        ListNode* curr = head->next;
        ListNode* prev = head;
        while(count<n){ //注意不是 <= n
            ListNode* nextCurr = curr->next;
            curr->next = prev;
            
            prev = curr;
            curr = nextCurr;
            
            count++;
        }
        
        //将主链和中间翻转的一小段链子连起来
        prevNode->next = prev;
        head->next = curr;
        
        return hair->next;
    }
};


class Solution {
public:
    ListNode *reverseBetween(ListNode *head, int m, int n) {
        //特殊情况
        if(m==n) return head;
        
        /*
        开头重新加一个节点， 不然m==1的时候会很麻烦
        */
        
        int i = -1; //考虑到hair
        ListNode* hair = new ListNode(0);
        hair->next = head;
        
        ListNode* prev; //上一个
        ListNode* cur; //当前，每次把 cur->prev
        ListNode* nextCur; //用于保存下一个cur在哪里
        ListNode* startNode; //需要翻转部分的开头
        ListNode* startNode_prev; //需要翻转部分的开头的前驱
        ListNode* endNode; //需要翻转部分的结尾
        ListNode* endNode_post; //需要翻转部分的结尾的后继
        
        
        head = hair;
        
        while(true){
            //到这里的时候，如果prev和cur都已经有了， 那么i对应的就是prev， 后面就是cur
            
            i++; //i到这里代表目前是第几个节点 ， 0代表hair
            
            //到这里的时候，如果prev和cur都已经有了， 那么i对应的就是cur
            
            
            if(i==m-1){
                startNode_prev = head;
            }else if(i==m){//init
                startNode = head;
                
                prev = head;
                cur = head->next;
            }else if(i>m && i<n){
                //在i刚刚对应上cur的时候进行翻转
                
                //保存现场
                nextCur = cur->next;
                
                //翻转
                cur->next = prev;
                
                //update 指针
                prev = cur;
                cur = nextCur;
                
            }else if(i==n){
                //最后这个i对应的是 cur， 还要进行一次翻转
                
                //保存最后的现场
                endNode_post = cur->next;
                endNode = cur;
                
                //翻转 
                cur->next = prev;
                
                break;
            }
            
            //最后这个条件已经没用，而且会造成死循环：
            /*
            在 startNode_prev->next = startNode;
            startNode->next = n2;
            n2->next = startNode;
            这样就造成了闭环
            */
            //但是开始的时候必须要，不然指针跑不到m啊
            head = head->next;
        }
        
        //处理头和尾
        startNode_prev->next = endNode;
        startNode->next = endNode_post;
        
        return hair->next;
        
    }
};


