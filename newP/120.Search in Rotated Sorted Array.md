##Search in Rotated Sorted Array    


折半，
折半的精髓就在于每次都能去掉一半候选集， 把握住这个精髓， 就可以解决绝大多数 log(n)的算法


    class Solution {
    public:
        int search(int A[], int n, int target) {
            /*
            case1:
            4 5 6 7 0 1 2   , 1
            mid:7 :  4 5 6  |  0 1 2   not in left
            
            case2:
            2 4 5 6 7 0 1   , 1
            mid:6 : 2 4 5 | 7 0 1 not in left
            
            必然有一半有序，如果target存在， 必然存在于这一半或者必然不存在于这一半
            */
            int left = 0;
            int right = n-1;
            int mid;
            while(left<=right){
                mid=(left+right)/2;
                if(A[mid]==target){
                    break;
                }
                
                if(A[left]<=A[mid]){
                    if(A[left]<=target && target<=A[mid]){ //注意是 <=
                        right = mid-1;
                        continue;
                    }else{
                        left = mid+1;
                        continue;
                    }
                }else{ //必然有 A[mid]<A[right]
                    if(A[mid]<=target&& target<=A[right]){ //注意是 <=
                        left = mid+1;
                        continue;
                    }else{
                        right=mid-1;
                        continue;
                    }
                }
            }
            if(A[mid]==target) return mid;
            else return -1;
        }
    };
