##Sort Colors    
已知一个数组只有  0 1 2， 排序，要求 one-pass 同时 使用 constant space。
首先可以肯定的是，需要四个指针，k0 k1 k2指向下一个要插入0 1 2的位置， i指向当前遍历到的元素， 具体有两种方法。
1. one-pass，但是不是constant-space
    新建一个大小为n的数组， k1 k2先指向头， 将k3指向尾
    如果来 0， k0++， 同时k1++, （在增加k0 k1之前，将其指向的位置置为0 1）， 相当于先插入k1处，然后交换
    如果来 1， 直接加入k1处, k1++
    如果来 2， 直接加入k2处，k2--
    
2. one-pass constant-space
    constant-space , 也就是说要在数组A的原地开搞。
    将k0 k1 k2都指向0
    如果来0， 直接和k0处的元素进行交换， 同时，为了防出现 120->021的状况，还要检测交换过来的是什么， 如果是1， 就要和k1处的元素再交换一次。 k0++ k1++ k2++
    如果来1， 直接和k1处的元素进行交换 k1++ k2++
    如果来2， 和k2处的元素进行交换 k2++
    
    如果来0， 放到k0处， 如果k1==k0 说明还没有1被覆盖， k1 k2 直接往后挪就好，不用干啥；否则， 就应该将k1处置为1，同时检查是否k1==k2,做类似操作
    如果来1， 放到k1处，检查是否有k1==k2
    如果来2 直接放到k2处 （按理说，在0 1 2 都出现了的情况下，k2应该和i指向同一个位置，所以可以省去一个指针，这种想法是错误的，因为刚开始的时候 0 1 2并没有都出现）
    
        void sortColors(int A[], int n) {
            //int* temp = new int[n];
            int k0=0;
            int k1=0;
            int k2=0;
            for(int i=0;i<n;i++){
                if(A[i]==0){
                    A[k0]=0;
                    
                    if(k0!=k1){ //说明刚才 A[k0]=0 占掉了一个1
                        A[k1]=1;
                    }
                    if(k1!=k2){ 
                        //说明刚才 被A[k0]==0 或者 A[k1]=1 占掉了一个2
                        //如果刚才是 k0==k1, 说明没有1呢， 被A[k0]=0占了
                        //如果刚才是 k0!=k1, 说明有1， 一定是被 A[k1]=1占了
                        A[k2]=2;
                    }
                    
                    k0++;
                    k1++;
                    k2++;
                    
                }else if(A[i]==1){
                    A[k1]=1;
                    if(k1!=k2){
                        A[k2]=2;
                    }
                    k1++;
                    k2++;
                }else{
                    A[k2]=2;
                    k2++;
                }
            }
        }


