##Subsets    

基础的全子集问题（所谓的回溯法)
和 Permutation Combination 一起看
思路： 一个指针从前往后遍历，遇到一个元素，决定要不要往子集里面加。
子集一共有 2^n 个， n是元素个数


	class Solution {
	public:
	    vector<vector<int> > subsets(vector<int> &S) {
	        vector<int>  oneSubset;
	        sort(S.begin(),S.end()); //别忘记排序
	        subset(S,0,oneSubset);
	        return output;
	        
	    }
	    
	    void subset(vector<int>&s, int idx, vector<int> oneSubset){
	        if(s.size() == idx){
	            output.push_back(oneSubset);
	            return;
	        }
	        
	        //两种选择， 添加 或者 不添加
	        //没哟for循环
	        

	        //1. 添加 idx 指向的元素
	        oneSolution.push_back(S[currIdx]);
        	subsetsHelper(S,currIdx+1,oneSolution);
        	oneSolution.pop_back();
        	/*
        	这个要差一些
	        vector<int> oneSubset_ = oneSubset;
	        oneSubset_.push_back(s[idx]);
	        subset(s, idx+1, oneSubset_);
	        */
	        
	        //2. 不添加
	        subset(s, idx+1, oneSubset);
	        
	    }
	private:
	    vector<vector<int> > output;
	    
	};

2. 迭代解法

class Solution {
public:
    vector<vector<int> > subsets(vector<int> &S) {
        /*
        递推法
        case: 1 2 3
        
        X 
        X 1
        X 1 2 12 
        X 1 2 12 3 13 23 123
        */
        
        const int n = S.size();
        vector<vector<int>> output(pow(2,n));
        output[0] = vector<int>();
        sort(S.begin(),S.end());
        int curr_idx=1; //下一个待插入的位置
        for(int elem:S){
            int last_currIdx = curr_idx;
            for(int i=0;i<last_currIdx;i++){
                output[i].push_back(elem);
                output[curr_idx++] = output[i];
                output[i].pop_back();
            }
        }
        return output;
    }
};

3. 高手的迭代解法

	vector<vector<int> > subsets(vector<int> &S) {
	    sort(S.begin(), S.end());
	    vector<vector<int> > v(1);
	    for(int i = 0; i < S.size(); ++i) {
	        int j = v.size();
	        while(j-- > 0) {
	            v.push_back(v[j]);
	            v.back().push_back(S[i]);
	        }
	    }
	    return v;
	}
