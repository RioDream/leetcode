##Clone Graph    




		class Solution {
		public:
		    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {
		        if(!node) return NULL;
		        if(visited.count(node)>0) return visited[node];
		        
		        UndirectedGraphNode* newGraphNode = new UndirectedGraphNode(node->label);
		        
		        visited[node] = newGraphNode;
		        
		        for(int i=0;i<node->neighbors.size();i++){
		            UndirectedGraphNode* nei = node->neighbors[i];
		            newGraphNode->neighbors.push_back(cloneGraph(nei));
		        }
		        
		        return newGraphNode;
		    }

		private:
		    map<UndirectedGraphNode*,UndirectedGraphNode*> visited;
		};


		class Solution {
		public:
		    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {
		        if(!node) return NULL;

		        //node已经被clone，但是不该返回node，而是应该返回对应的clone出来的新的node
		        if(visited.count(node)>0) return node; 
		        
		        UndirectedGraphNode* newGraphNode = new UndirectedGraphNode(node->label);
		        
		        visited.insert(newGraphNode);
		        
		        for(int i=0;i<node->neighbors.size();i++){
		            UndirectedGraphNode* nei = node->neighbors[i];

		            //尽管做了这样的处理，但是在else中的cloneGraph遇到clone过的node时，还是会发生错误
		            if(nei==node) newGraphNode->neighbors.push_back(newGraphNode);
		            else newGraphNode->neighbors.push_back(cloneGraph(nei));
		        }
		        
		        return newGraphNode;
		    }

		private:
		    set<UndirectedGraphNode*> visited;
		};

