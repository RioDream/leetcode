##Reverse Nodes in k-Group    


class Solution {
public:
    ListNode *reverseKGroup(ListNode *head, int k) {
        if(!head) return NULL;
        
        ListNode* hair = new ListNode(-1);
        hair->next = head;
        ListNode* h_prev = hair;
        ListNode* t_post;
        ListNode* h = head;
        ListNode* t = head;
        int count = 1;
        while(true){ //可以是true，也可以是 while(h), 很细节的问题
            //step1. t指针走k步
            while(t && count!=k){
                t = t->next;
                count++;
            }
            if(!t) break;
            
            //step2. 将翻转之后的k个节点进行重新连接
            t_post = t->next;
            t->next = NULL; //注意这一句对于reverseList函数是很有帮助的
            reverseList(h,t);
            h_prev->next = h;
            t->next = t_post;
            
            //step3. update h和t， 准备下一次的更新
            h_prev = t;
            h = t_post;
            t = h;
            count = 1;
        }
        return hair->next;
    }

private:
    //翻转链表
    void reverseList(ListNode*& head, ListNode*& tail){
        ListNode* nextCurr;
        ListNode* curr = head->next;
        ListNode* prev = head;
        swap(head, tail);
        while(curr){
            nextCurr = curr->next;
            curr->next = prev;
            
            prev = curr;
            curr = nextCurr;
        }
    }
};


早期一个比较复杂的版本， 可以看到使用函数的好处

		class Solution {
		public:
		    ListNode *reverseKGroup(ListNode *head, int k) {
		        if(k==1) return head;
		        
		        ListNode* hair = new ListNode(0);
		        hair->next = head;
		        
		        ListNode* startNode_prev = hair;
		        ListNode* startNode;
		        ListNode* endNode;
		        ListNode* endNode_post;
		        ListNode* prev = hair;
		        ListNode* cur = head;
		        ListNode* nextCur;
		        
		        int i = 0;
		        
		        while(cur){
		            
		            i++;
		            
		            //i这时和cur对应
		            
		            if(i==1){
		                startNode = cur;
		                
		                //update
		                prev = cur;
		                cur = cur->next;
		            }else if(i<k){
		                
		                nextCur = cur->next;
		                
		                //
		                cur->next = prev;
		             
		                prev = cur;
		                cur = nextCur;
		                    
		            }else if(i==k){
		                
		                nextCur = cur->next;
		                
		                //翻转
		                cur->next = prev;
		             
		                endNode = cur;
		                endNode_post = nextCur;
		                
		                //连接
		                startNode_prev->next = endNode;
		                startNode->next = endNode_post;
		                
		                //为翻转下一次k个做准备
		                cur = nextCur;
		                startNode_prev = startNode;
		                
		                i=0; //不是1
		            }
		            
		        }
		        
		        //startNodePrev -> startNode <= n1 <= prev <= cur
		        if(i<k && i>1){ //i==1的时候还没有翻转
		            while(true){
		                
		                ListNode* nextPrev = prev->next;
		                
		                prev->next = cur;
		                
		                if(prev==startNode) break;
		                
		                cur = prev;
		                prev = nextPrev;
		            }
		        }
		        
		        return hair->next;
		        
		    }
		    
		};
