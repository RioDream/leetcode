##Decode Ways    

class Solution {
public:
    /*
    思路：
    
    1. DFS递归
    在递归的过程中不断去剪枝，最后到解的数目就是decode的种数
    
    2. 动态规划
    比如：dp[i]表示第i个元素为止总共有多少种方法
    125100
    
    dp[0] = 1
    dp[1] = 1
    dp[2] = dp[0]+dp[1] //可以从0跳过来 (12)， 也可以从1跳过来(2)
    dp[3] = dp[1]+dp[2] //可以从1跳过来 (25)， 也可以从2跳过来(5)
    dp[4] = dp[3] //不可以从2跳过来 (51)， 可以从3跳过来(1)
    dp[5] = dp[3] //可以从3跳过来（10），不可以从4跳过来
    dp[6] = 0 //4（00）,5（0）都不能过来
    
    
    
    */
    int numDecodings(string s) {
        const int n = s.size();
        if(n==0) return 0;
        
        int* dp = new int[n+1]();
        dp[0] = 1;
        int jump1StepWays;
        int jump2StepWays;
        for(int i=1;i<=n;i++){
            if(s[i-1]<='0'||s[i-1]>'9') jump1StepWays=0;
            else jump1StepWays=dp[i-1];
            
            if(s[i-2]<='0'||s[i-2]>'9'||i==1||s[i-2]>'2' ||(s[i-2]=='2'&&s[i-1]>'6')) jump2StepWays=0;
            else jump2StepWays=dp[i-2];
            
            dp[i] = jump1StepWays+jump2StepWays;
        }
        return dp[n];
    }
};
